(*
 * Caffettiera
 * MGen
 * bomtemplates.fs: code template for BOM generation [C#]
 * (C) 2008 Alvise Spano' @ Netical
 *)
 
#light "off" 

namespace Caffettiera.FSharp.Generator

module BOAMTemplates =
  struct
    open Caffettiera.FSharp.Generator
    open Caffettiera.FSharp.Generator.Gen
    open Caffettiera.FSharp.Common.Prelude
  
    let compilation_item =
        Template (["NAME"; "USINGS"; "NAMESPACE"; "BODY"],
        "//
        // BLL/BOAM [C#]
        // $NAME$
        //
        // Generated by MGen/Caffettiera
        // (C) 2008 Netical 
        //
        
        $USINGS$
        
        namespace $NAMESPACE$.BOAM
        {
        
        $BODY$
        
        }
        ")
  
    let usings =
        Template ([],
        "using System;
        using System.Collections;
        using System.Collections.Generic;
        using Caffettiera.CSharp.Common;
        using Caffettiera.CSharp.BLL;
        ")
  
    let isvalidexpr_term =
        Template (["NAME"], "$NAME$.IsValid()")
 
    let simple_property =
        Template (["TYPE"; "NAME"],
        "private $TYPE$ _$NAME$;
        
        public $TYPE$ $NAME$
        {
            get { return _$NAME$; }
            set { _$NAME$ = value; }
        }
        ")
            
	let __method =
		Template (["NAME"; "RTYPE"; "ARGS"; "BODY"],
		"public $RTYPE$ $NAME$($ARGS$)
		{
			$BODY$
		}
		")
        
    let method_arg = Template (["NAME"; "TYPE"], "$TYPE$ $NAME$")    
        
    let method_signature = Template (["NAME"; "RTYPE"; "ARGS"], "$RTYPE$ $NAME$($ARGS$);")    
        
	let ext_action_method =
		TemplateMap (["NAME"; "RTYPE"; "ARGS"],
		["BODY",
		    "// insert code here
		    throw new NotImplementedException(\"method $NAME$ not implemented\");
		    "],
		__method)
          
	let ext_business_object_avatar_interface =
		Template (["NAME"; "ACTIONS"],
		"internal interface I$NAME$Ext
		{
			$ACTIONS$
		}
		")
          
	let ext_business_object_avatar =
		Template (["NAME"; "ACTIONS"],
		"public partial class $NAME$ : I$NAME$Ext
		{
			$ACTIONS$
		}
		")  
          
    let business_object_avatar =
        Template (["NAME"; "BASE"; "ABSTRACT"; "NEW"; "VIRTUAL"; "BODY"; "ISVALIDEXPR"],
        "public partial $ABSTRACT$ class $NAME$ $BASE$
        {
        
			private int? uid;
            
            #region Constructors
            
            public $NAME$()
            {
				uid = null;
            }
            
            protected internal $NAME$(int uid)
            {
				if (uid == 0) this.uid = null;
				else this.uid = uid;
            }
            
            #endregion

            public static $NEW$ $NAME$ Create()
            {
                return new $NAME$();
            }

            public $VIRTUAL$ bool IsValid()
            {
                return $ISVALIDEXPR$;
            }
            
            public $VIRTUAL$ int? UId
            {
                get { return uid; }
            }
              
            public $NEW$ void SetPropertyByName<T>(string name, T x)
            {
                this.GetType().GetProperty(name, typeof(T)).SetValue(this, x, null);
            }

            public $NEW$ void SetPropertyByNameFromString(string name, string x)
            {
                Type[] tys = { typeof(string) };
                object[] args = { x };
                var p = this.GetType().GetProperty(name);
                try
                {
                    p.SetValue(this, p.PropertyType.GetConstructor(tys).Invoke(args), null);
                }
                catch (System.ArgumentException e)
                {
                    throw new UnexpectedException(string.Format(\"type '{0}' does not provide a constructor from 'string'\", p.PropertyType), e);
                }
            }

            public $NEW$ T GetPropertyByName<T>(string name)
            {
                return (T)this.GetType().GetProperty(name, typeof(T)).GetValue(this, null);
            }                      
        
            $BODY$
        }
        ")

    let specialized_isvalidexpr =
        Template (["EXPR"], "base.IsValid() && $EXPR$")

    
    (* association *)
  
    let association =
        Template (["SOURCE"; "NAME"; "TYPE"; "TARGET"; "REVTYPE"],
        "#region $SOURCE$-to-$TARGET$ Association
        
        protected internal $SOURCE$ _$NAME$$TYPE$$SOURCE$ = null;

        public $SOURCE$ $NAME$$TYPE$$SOURCE$
        {
            get { return _$NAME$$TYPE$$SOURCE$; }
            
            set
            {
				if (_$NAME$$TYPE$$SOURCE$ != null) _$NAME$$TYPE$$SOURCE$._$NAME$$REVTYPE$$TARGET$ = null;
				_$NAME$$TYPE$$SOURCE$ = value;
				if (value != null) value._$NAME$$REVTYPE$$TARGET$ = this;
			}
        }
        
        #endregion
        ")
        
  
	(* aggregation and composition *)
  
    let aggregation_and_composition_body_sourceside =
        Template (["NAME"; "SOURCE"; "TARGET"; "TYPE"; "REVTYPE"],
        "protected internal List<$SOURCE$> _$NAME$$REVTYPE$$SOURCE$ = null;

        public List<$SOURCE$> $NAME$$REVTYPE$$SOURCE$
        {
            get { return _$NAME$$REVTYPE$$SOURCE$; }
            
            set
            {
				if (_$NAME$$REVTYPE$$SOURCE$ != null)
					foreach(var x in _$NAME$$REVTYPE$$SOURCE$) x._$NAME$$TYPE$$TARGET$ = null;
				_$NAME$$REVTYPE$$SOURCE$ = value;
				if (value != null)
					foreach(var x in _$NAME$$REVTYPE$$SOURCE$) x._$NAME$$TYPE$$TARGET$ = this;
			}
        }
        ")
        
    let aggregation_and_composition_body_targetside =
        Template (["TYPE"; "NAME"; "TARGET"; "SOURCE"; "REVTYPE"],
        "protected internal $TARGET$ _$NAME$$REVTYPE$$TARGET$ = null;

        public $TARGET$ $NAME$$REVTYPE$$TARGET$
        {
            get { return _$NAME$$REVTYPE$$TARGET$; }
            
            set
            {
				if (_$NAME$$REVTYPE$$TARGET$ != null && _$NAME$$REVTYPE$$TARGET$._$NAME$$TYPE$$SOURCE$ != null && _$NAME$$REVTYPE$$TARGET$ != value)
					_$NAME$$REVTYPE$$TARGET$._$NAME$$TYPE$$SOURCE$.RemoveAll((bo) => bo == this);
				_$NAME$$REVTYPE$$TARGET$ = value;
				if (value != null && value._$NAME$$TYPE$$SOURCE$ != null && !value._$NAME$$TYPE$$SOURCE$.Exists((bo) => bo == this))
					value._$NAME$$TYPE$$SOURCE$.Add(this);
			}				
        }
        ")
  
    let aggregation_region =
        Template (["TARGET"; "SOURCE"; "BODY"],
        "#region $SOURCE$-to-$TARGET$ Aggregation
        
        $BODY$
        
        #endregion
        ")
        
    let composition_region =
        Template (["TARGET"; "SOURCE"; "BODY"],
        "#region $SOURCE$-to-$TARGET$ Composition
        
        $BODY$
        
        #endregion
        ")
        
  
  end