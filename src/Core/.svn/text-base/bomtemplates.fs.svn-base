(*
 * Caffettiera
 * MGen
 * bomtemplates.fs: code template for BOM generation [C#]
 * (C) 2008 Alvise Spano' @ Netical
 *)
 
#light "off" 

namespace Caffettiera.FSharp.Generator

module BOMTemplates =
  struct
    open Caffettiera.FSharp.Generator
    open Caffettiera.FSharp.Generator.Gen
    open Caffettiera.FSharp.Common.Prelude
  
    let compilation_item =
        Template (["NAME"; "USINGS"; "NAMESPACE"; "BODY"],
        "//
        // BLL/BOM [C#]
        // $NAME$
        //
        // Generated by MGen/Caffettiera
        // (C) 2008 Netical 
        //
        
        $USINGS$
        
        namespace $NAMESPACE$.BOM
        {
        
        $BODY$
        
        }
        ")
  
    let usings =
        Template ([],
        "using System;
        using System.Collections;
        using System.Collections.Generic;
        using Caffettiera.CSharp.Common;
        using Caffettiera.CSharp.BLL;
        using Caffettiera.CSharp.BLL.BOM;
        ")
  
	let transaction =
		Template (["NETTIERSNAME"],
		"/// <summary>
		/// Transaction type representing a transactional instance for committing business objects.
		/// This class auto-implements the ITransaction interface by F-binding itself to the type
		/// parameter, thus not losing type informations on its own type.
		/// </summary>
		public class Transaction : ITransaction<Transaction>
		{
			protected $NETTIERSNAME$.Data.TransactionManager tm;

			public Transaction()
			{
				tm = new $NETTIERSNAME$.Data.TransactionManager($NETTIERSNAME$.Data.DataRepository.ConnectionStrings[\"$NETTIERSNAME$.Data.ConnectionString\"].ConnectionString);
			}
            			
			public R Do<R>(Func<Transaction, R> f)
			{
				tm.BeginTransaction();
				try
				{
					R r = f(this);
					tm.Commit();
					return r;
				}
				catch (Exception e)
				{
					tm.Rollback();
					throw e;
				}
			}

			public void Do(Action<Transaction> f)
			{
				Do<object>((t) => { f(t); return null; });
			}

			protected internal $NETTIERSNAME$.Data.TransactionManager transactionManager
	        {
		        get { return tm; }
			}
		}
		")
  
    let bo =
        Template (["NETTIERSNAME"],
        "/// <summary>
		/// Status of a business objects can be one of these.
		/// </summary>
		public enum Status { Valid, ToBeRemoved, Removed }
        
        /// <summary>
	    /// Business object wrapper supporting NetTiers Entity-Provider pattern. Used internally by generated BOs.
	    /// </summary>
	    /// <typeparam name=\"Key\">NetTiers EntityKey type.</typeparam>
	    /// <typeparam name=\"Entity\">NetTiers Entity type.</typeparam>
	    /// <typeparam name=\"ProviderBase\">NetTiers Provider type.</typeparam>
        public class BO<Key, Entity, ProviderBase>
            where Key : $NETTIERSNAME$.Entities.IEntityKey, new()
            where Entity : $NETTIERSNAME$.Entities.IEntityId<Key>, new()
            where ProviderBase : $NETTIERSNAME$.Data.Bases.EntityProviderBase<Entity, Key>
        {
            protected internal Entity entity;
            protected internal ProviderBase providerBase;
            protected bool committing;
            protected Status status;

            protected internal BO(Entity e, ProviderBase p)
            {
                entity = e;
                providerBase = p;
                status = Status.Valid;
            }

            protected internal BO(ProviderBase p) : this(new Entity(), p) {}

            protected internal BO(Key k, ProviderBase p) : this(p.Get(k), p) {}

            public void Save(Transaction t)
            {
                switch (status)
                {
                    case Status.Valid:
                        providerBase.Save(t.transactionManager, entity);
                        break;

                    case Status.ToBeRemoved:
                        providerBase.Delete(t.transactionManager, entity);
                        status = Status.Removed;
                        break;

                    case Status.Removed:
                        throw new InvalidOperationException(string.Format(\"business object '{0}' has been removed\", GetType().Name));
                }
            }

            public void MarkToRemove()
            {
                entity.MarkToDelete();
                status = Status.ToBeRemoved;
            }

            public Status Status
            {
                get { return status; }
            }

            public void Committing(Action f)
            {
                if(status == Status.Removed)
                    throw new InvalidOperationException(string.Format(\"business object '{0}' has been removed\", GetType().Name));
                if (committing) return;
                else
                {
                    committing = true;
                    try { f(); }
                    finally { committing = false; }
                }
            }

            public static IList<BO> RetrieveAll<BO>(Func<Entity, BO> f, Func<BO, bool> pf, ProviderBase p)
            {
                IList<BO> r = new List<BO>();
                foreach (Entity e in p.GetAll())
                {
                    var bo = f(e);
                    if(pf(bo)) r.Add(bo);
                }
                return r;
            }

            public void SetPropertyByName<T>(string name, T x)
            {
                this.GetType().GetProperty(name, typeof(T)).SetValue(this, x, null);
            }

            public void SetPropertyByNameFromString(string name, string x)
            {
                Type[] tys = { typeof(string) };
                object[] args = { x };
                var p = this.GetType().GetProperty(name);
                try
                {
                    p.SetValue(this, p.PropertyType.GetConstructor(tys).Invoke(args), null);
                }
                catch (System.ArgumentException e)
                {
                    throw new UnexpectedException(string.Format(\"type '{0}' does not provide a constructor from 'string'\", p.PropertyType), e);
                }
            }

            public T GetPropertyByName<T>(string name)
            {
                return (T)this.GetType().GetProperty(name, typeof(T)).GetValue(this, null);
            }
        }
        ")
 
    let isvalidexpr_term =
        Template (["NAME"], "$NAME$.IsValid()")
 
    let simple_property =
        Template (["TYPE"; "NAME"],
        "public $TYPE$ $NAME$
        {
            get { return bo.entity.$NAME$; }
            set { bo.entity.$NAME$ = value; }
        }
        ")
            
	let __method =
		Template (["NAME"; "RTYPE"; "ARGS"; "BODY"],
		"public $RTYPE$ $NAME$($ARGS$)
		{
			$BODY$
		}
		")
        
    let method_arg = Template (["NAME"; "TYPE"], "$TYPE$ $NAME$")    
        
    let method_signature = Template (["NAME"; "RTYPE"; "ARGS"], "$RTYPE$ $NAME$($ARGS$);")    
        
	let ext_action_method =
		TemplateMap (["NAME"; "RTYPE"; "ARGS"],
		["BODY",
		    "// insert code here
		    throw new NotImplementedException(\"method $NAME$ not implemented\");
		    "],
		__method)
          
	let ext_business_object_interface =
		Template (["NAME"; "ACTIONS"],
		"internal interface I$NAME$Ext
		{
			$ACTIONS$
		}
		")
          
	let ext_business_object =
		Template (["NAME"; "ACTIONS"],
		"public partial class $NAME$ : I$NAME$Ext
		{
			$ACTIONS$
		}
		")  
          
    let business_object =
        Template (["NETTIERSNAME"; "NAMESPACE"; "PROPASSIGNS"; "NAME"; "BASE"; "ABSTRACT"; "NEW"; "VIRTUAL"; "BODY"; "ISVALIDEXPR"; "CONSTRUCTORS"],
        "public partial $ABSTRACT$ class $NAME$ : $BASE$ IBO<Transaction>
        {
            protected internal $NEW$ BO<$NETTIERSNAME$.Entities.$NAME$Key, $NETTIERSNAME$.Entities.$NAME$, $NETTIERSNAME$.Data.Bases.$NAME$ProviderBase> bo;
        
            #region Constructors
            
            $CONSTRUCTORS$
            
            #endregion

			public static implicit operator $NAMESPACE$.BOAM.$NAME$($NAME$ x)
			{
				var r = new $NAMESPACE$.BOAM.$NAME$(x.UId);
				$PROPASSIGNS$
				return r;
			}

			public static implicit operator $NAME$($NAMESPACE$.BOAM.$NAME$ x)
			{
			    var r = x.UId.HasValue ? new $NAME$(x.UId.Value) : new $NAME$();
			    $PROPASSIGNS$
				return r;
			}
        
            public static $NEW$ $NAME$ Create()
            {
                return new $NAME$();
            }

            public static $NEW$ $NAME$ RetrieveByUId(int k)
            {
                var r = new $NAME$(k);
                return r.bo.entity == null ? null : r;
            }
            
            public static $NEW$ IList<$NAME$> RetrieveAll()
            {
                return BO<$NETTIERSNAME$.Entities.$NAME$Key,
                          $NETTIERSNAME$.Entities.$NAME$,
                          $NETTIERSNAME$.Data.Bases.$NAME$ProviderBase>.RetrieveAll<$NAME$>
                            ((e) => new $NAME$(e),
                            (bo) => true,
                            $NETTIERSNAME$.Data.DataRepository.$NAME$Provider);
            }
            
            public static $NEW$ IList<$NAME$> RetrieveAll(Func<$NAME$, bool> p)
            {
                return BO<$NETTIERSNAME$.Entities.$NAME$Key,
                          $NETTIERSNAME$.Entities.$NAME$,
                          $NETTIERSNAME$.Data.Bases.$NAME$ProviderBase>.RetrieveAll<$NAME$>
                            ((e) => new $NAME$(e),
                            p,
                            $NETTIERSNAME$.Data.DataRepository.$NAME$Provider);
            }

            public $VIRTUAL$ bool IsValid()
            {
                return $ISVALIDEXPR$;
            }
            
            public $VIRTUAL$ int UId
            {
                get { return bo.entity.ID; }
            }
            
            public virtual void Commit(Transaction tr)
			{
				RecCommit(tr);
			}

			public virtual void Commit()
			{
				new Transaction().Do(RecCommit);
			}
            
            public $VIRTUAL$ void Remove()
            {
                bo.MarkToRemove();
            }
                     
            public $NEW$ void SetPropertyByName<T>(string name, T x)
            {
                bo.SetPropertyByName<T>(name, x);
            }

            public $NEW$ void SetPropertyByNameFromString(string name, string x)
            {
                bo.SetPropertyByNameFromString(name, x);
            }

            public $NEW$ T GetPropertyByName<T>(string name)
            {
                return bo.GetPropertyByName<T>(name);
            }
        
            $BODY$
        }
        ")


	(* isvalid *)

    let specialized_isvalidexpr =
        Template (["EXPR"], "base.IsValid() && $EXPR$")

	
	(* property assignment *)
	
	let __prop_assign = Template (["TO"; "FROM"; "NAME"], "$TO$.$NAME$ = $FROM$.$NAME$;")
	
	let prop_assign_from_x_to_r =
		TemplateMap (["NAME"],
		["TO", "r";
		 "FROM", "x"],
		__prop_assign)
	

	(* constructors *)

    let constructors =
        Template (["NETTIERSNAME"; "NAMESPACE"; "NAME"; "INTBASECONSTRUCTOR"; "ENTITYBASECONSTRUCTOR"; "EMPTYBASECONSTRUCTOR"],
        "protected internal $NAME$(int k) $INTBASECONSTRUCTOR$
        {
            this.bo = new BO<$NETTIERSNAME$.Entities.$NAME$Key,
                             $NETTIERSNAME$.Entities.$NAME$,
                             $NETTIERSNAME$.Data.Bases.$NAME$ProviderBase>
                             (new $NETTIERSNAME$.Entities.$NAME$Key(k),
                             $NETTIERSNAME$.Data.DataRepository.$NAME$Provider);
        }
        
        protected internal $NAME$($NETTIERSNAME$.Entities.$NAME$ e) $ENTITYBASECONSTRUCTOR$
        {
            this.bo = new BO<$NETTIERSNAME$.Entities.$NAME$Key,
                             $NETTIERSNAME$.Entities.$NAME$,
                             $NETTIERSNAME$.Data.Bases.$NAME$ProviderBase>
                             (e, $NETTIERSNAME$.Data.DataRepository.$NAME$Provider);
        }

        public $NAME$() $EMPTYBASECONSTRUCTOR$
        {
            this.bo = new BO<$NETTIERSNAME$.Entities.$NAME$Key,
                             $NETTIERSNAME$.Entities.$NAME$,
                             $NETTIERSNAME$.Data.Bases.$NAME$ProviderBase>
                             ($NETTIERSNAME$.Data.DataRepository.$NAME$Provider);
        }
        
        public $NAME$(Env<Transaction> env) : this()
        {
            env.Add(this);
        }
        ")

    let specialized_intbaseconstructor =
        Template ([], ": base(k)")

    let specialized_entitybaseconstructor =
        Template ([], ": base(e.ID)")

    let specialized_emptybaseconstructor =
        Template ([], ": base()")
    
    let reccommit =
        Template (["NETTIERSNAME"; "VIRTUAL"; "BODY"],
            "protected internal $VIRTUAL$ void RecCommit(Transaction t)
            {
                bo.Committing(() =>
                    {
                        $BODY$
                    });
            }
            ")
  
    let commit_self =
        Template ([],
        "bo.Save(t);
        ")
  
    let commit_supertype =
        Template ([],
        "base.RecCommit(t);
         bo.entity.ID = base.bo.entity.ID;
         ")
         
    let __commit_relation_oneside =
        Template (["SIDE"; "NAME"; "TYPE"],
        "if (_$NAME$$TYPE$$SIDE$ != null)
        {
            _$NAME$$TYPE$$SIDE$.RecCommit(t);
            if (_$NAME$$TYPE$$SIDE$.bo.Status == Status.Removed)
            {
				_$NAME$$TYPE$$SIDE$ = null;
				bo.entity.$NAME$$TYPE$$SIDE$ID = null;
			}
            else bo.entity.$NAME$$TYPE$$SIDE$ID = _$NAME$$TYPE$$SIDE$.bo.entity.ID;
        }
        ")
        
     let __commit_relation_manyside =
        Template (["TARGET"; "SOURCE"; "NAME"; "TYPE"; "REVTYPE"],
        "if (_$NAME$$REVTYPE$$SOURCE$ != null)
        {
			_$NAME$$REVTYPE$$SOURCE$.ReallyRemove((x) =>
                {
                    x._$NAME$$TYPE$$TARGET$ = this;
                    x.RecCommit(t);
                    return x.bo.Status == Status.ToBeRemoved;
                });
        }
        ")
         
    let __commit_relation_oneside_as_target =
		TemplateMap (["TARGET"; "NAME"; "TYPE"; "REVTYPE"],
		["SIDE", "$TARGET$";
		 "TYPE", "$REVTYPE$"],
		__commit_relation_oneside)
		
	 let __commit_relation_oneside_as_source =
		TemplateMap (["SOURCE"; "NAME"; "TYPE"; "REVTYPE"],
		["SIDE", "$SOURCE$";
		 "TYPE", "$REVTYPE$"],
		__commit_relation_oneside)
		
    let commit_composition_targetside = __commit_relation_oneside_as_target
		
    let commit_composition_removal_sourceside =
        Template (["SOURCE"; "NAME"; "REVTYPE"],
        "if (_$NAME$$REVTYPE$$SOURCE$ != null)
        {
            bool b = true;
            foreach (var x in _$NAME$$REVTYPE$$SOURCE$)
            {
                b &= x.bo.Status == Status.ToBeRemoved || x.bo.Status == Status.Removed;
            }
            if (b) this.Remove();
        }
        ")
        
    let commit_composition_sourceside = __commit_relation_manyside
        
    let commit_aggregation_targetside = __commit_relation_oneside_as_target
        
    let commit_aggregation_sourceside = __commit_relation_manyside

    let commit_association_sourceside = __commit_relation_oneside_as_source
  
    let commit_association_targetside =
        Template (["TARGET"; "NAME"; "REVTYPE"],
        "if (_$NAME$$REVTYPE$$TARGET$ != null)
        {
            _$NAME$$REVTYPE$$TARGET$.RecCommit(t);
            if (_$NAME$$REVTYPE$$TARGET$.bo.Status == Status.Removed) _$NAME$$REVTYPE$$TARGET$ = null;
        }
        ")
  
    let association_sourceside =
        Template (["SOURCE"; "NAME"; "TYPE"; "TARGET"; "REVTYPE"],
        "#region $SOURCE$-to-$TARGET$ Association
        
        protected internal $SOURCE$ _$NAME$$TYPE$$SOURCE$ = null;

		public bool Has$NAME$$TYPE$$SOURCE$
		{
			get { return _$NAME$$TYPE$$SOURCE$ != null || bo.entity.$NAME$$TYPE$$SOURCE$ID.HasValue; }
		}
		
        public $SOURCE$ $NAME$$TYPE$$SOURCE$
        {
            get
            {
                if (_$NAME$$TYPE$$SOURCE$ == null)
                {
                    int? id = bo.entity.$NAME$$TYPE$$SOURCE$ID;
                    if (id.HasValue)
                    {
                        _$NAME$$TYPE$$SOURCE$ = new $SOURCE$(id.Value);
                    }
                    else
                    {
                        _$NAME$$TYPE$$SOURCE$ = new $SOURCE$();
                        _$NAME$$TYPE$$SOURCE$._$NAME$$REVTYPE$$TARGET$ = this;
                    }
                }
                return _$NAME$$TYPE$$SOURCE$;
            }
        }
        
        #endregion
        ")
        
    let association_targetside =
        Template (["SOURCE"; "NAME"; "TYPE"; "TARGET"; "REVTYPE"],
        "#region $SOURCE$-to-$TARGET$ Association
        
        protected internal $TARGET$ _$NAME$$TYPE$$TARGET$ = null;
        
   		public bool Has$NAME$$TYPE$$TARGET$
		{
			get { return _$NAME$$TYPE$$TARGET$ != null || bo.entity.$TARGET$ != null; }
		}

        public $TARGET$ $NAME$$TYPE$$TARGET$
        {
            get
            {
                if (_$NAME$$TYPE$$TARGET$ == null)
                {
                    if (bo.entity.$TARGET$ == null) _$NAME$$TYPE$$TARGET$ = new $TARGET$();
                    else _$NAME$$TYPE$$TARGET$ = new $TARGET$(bo.entity.$TARGET$);
                    _$NAME$$TYPE$$TARGET$._$NAME$$REVTYPE$$SOURCE$ = this;
                }
                return _$NAME$$TYPE$$TARGET$;
            }
        }
        
        #endregion
        ")
  
    let aggregation_and_composition_body_sourceside =
        Template (["NAME"; "SOURCE"; "TARGET"; "TYPE"; "REVTYPE"; "NETTIERSNAME"],
        "protected internal Aggregation<$SOURCE$, Transaction> _$NAME$$REVTYPE$$SOURCE$ = null;

        public ICollection<$SOURCE$> $NAME$$REVTYPE$$SOURCE$
        {
            get
            {
                if (_$NAME$$REVTYPE$$SOURCE$ == null)
                    _$NAME$$REVTYPE$$SOURCE$ = CollectionMapper<Aggregation<$SOURCE$, Transaction>, $SOURCE$>.map<$NETTIERSNAME$.Entities.$SOURCE$>
                            ($NETTIERSNAME$.Data.DataRepository.$SOURCE$Provider.GetBy$NAME$$TYPE$$TARGET$ID(bo.entity.ID),
                            (e) => new $SOURCE$(e),
                            () => new Aggregation<$SOURCE$, Transaction>(($SOURCE$ x) => { x._$NAME$$TYPE$$TARGET$ = this; return x; }));
                return _$NAME$$REVTYPE$$SOURCE$;
            }
        }
        ")
        
    let aggregation_and_composition_body_targetside =
        Template (["TYPE"; "NAME"; "TARGET"; "SOURCE"; "REVTYPE"],
        "protected internal $TARGET$ _$NAME$$REVTYPE$$TARGET$ = null;

		public bool Has$NAME$$REVTYPE$$TARGET$
		{
			get { return _$NAME$$REVTYPE$$TARGET$ != null || bo.entity.$NAME$$REVTYPE$$TARGET$ID.HasValue; }
		}

		public void Unlink$NAME$$REVTYPE$$TARGET$()
		{
			bo.entity.$NAME$$REVTYPE$$TARGET$ID = null;
			if (_$NAME$$REVTYPE$$TARGET$ != null)
			{
				_$NAME$$REVTYPE$$TARGET$._$NAME$$TYPE$$SOURCE$.ReallyRemove(this);
				_$NAME$$REVTYPE$$TARGET$ = null;
			}			
        }
        
        public $TARGET$ $NAME$$REVTYPE$$TARGET$
        {
            get
            {
                if (_$NAME$$REVTYPE$$TARGET$ == null)
                {
                    int? id = bo.entity.$NAME$$REVTYPE$$TARGET$ID;
                    if (id.HasValue)
                    {
                        _$NAME$$REVTYPE$$TARGET$ = new $TARGET$(id.Value);
                    }
                    else
                    {
                        _$NAME$$REVTYPE$$TARGET$ = new $TARGET$();
                        _$NAME$$REVTYPE$$TARGET$.$NAME$$TYPE$$SOURCE$.Add(this);
                    }
                }
                return _$NAME$$REVTYPE$$TARGET$;
            }
		}
        ")
  
    let aggregation_region =
        Template (["TARGET"; "SOURCE"; "BODY"],
        "#region $SOURCE$-to-$TARGET$ Aggregation
        
        $BODY$
        
        #endregion
        ")
        
    let composition_region =
        Template (["TARGET"; "SOURCE"; "BODY"],
        "#region $SOURCE$-to-$TARGET$ Composition
        
        $BODY$
        
        #endregion
        ")
        
  
  end